clear all;
close all;
clc;
% This is the code for solving short term wind speed prediction 
actual=zeros(1,200);
predict=zeros(1,200);
% Import wind speed data from a dat file
%importfile('Chester2007.dat');
load Savoy;
data=Savoy;
% Choose proper wind speed data from all data set
speed=data(2000:2800,1);
speed=speed';
numberoftrainingdata=300;
numberoftestingdata=200;



% Solve an Autoregression Time-Series Problem with a NAR Neural Network
% Script generated by NTSTOOL
% Created Thu Sep 13 20:55:34 EDT 2012
%
% This script assumes this variable is defined:
%
%   speed - feedback time series.

targetSeries = tonndata(speed,true,false);

% Create a Nonlinear Autoregressive Network
feedbackDelays = 5:10
hiddenLayerSize = 9;
net = narnet(feedbackDelays,hiddenLayerSize);

% Choose Feedback Pre/Post-Processing Functions
% Settings for feedback input are automatically applied to feedback output
% For a list of all processing functions type: help nnprocess
net.inputs{1}.processFcns = {'removeconstantrows','mapminmax'};

% Prepare the Data for Training and Simulation
% The function PREPARETS prepares timeseries data for a particular network,
% shifting time by the minimum amount to fill input states and layer states.
% Using PREPARETS allows you to keep your original time series data unchanged, while
% easily customizing it for networks with differing numbers of delays, with
% open loop or closed loop feedback modes.
[inputs,inputStates,layerStates,targets] = preparets(net,{},{},targetSeries);

% Setup Division of Data for Training, Validation, Testing
% For a list of all data division functions type: help nndivide
net.divideFcn = 'divideind';  % Divide data by indicies
net.divideParam.trainInd = 1:300;
net.divideParam.valInd=301:490;
net.divideParam.testInd=491:700;
net.divideMode = 'time';  % Divide up every value
%net.divideParam.trainRatio = 70/100;
%net.divideParam.valRatio = 15/100;
%net.divideParam.testRatio = 15/100;

% Choose a Training Function
% For a list of all training functions type: help nntrain
net.trainFcn = 'trainlm';  % Levenberg-Marquardt

% Choose a Performance Function
% For a list of all performance functions type: help nnperformance
net.performFcn = 'mse';  % Mean squared error

% Choose Plot Functions
% For a list of all plot functions type: help nnplot
net.plotFcns = {'plotperform','plottrainstate','plotresponse', ...
  'ploterrcorr', 'plotinerrcorr'};


% Train the Network
[net,tr] = train(net,inputs,targets,inputStates,layerStates);

% Test the Network
outputs = net(inputs,inputStates,layerStates);
errors = gsubtract(targets,outputs);
performance = perform(net,targets,outputs)

% Recalculate Training, Validation and Test Performance
trainTargets = gmultiply(targets,tr.trainMask);
valTargets = gmultiply(targets,tr.valMask);
testTargets = gmultiply(targets,tr.testMask);
trainPerformance = perform(net,trainTargets,outputs)
valPerformance = perform(net,valTargets,outputs)
testPerformance = perform(net,testTargets,outputs)

% View the Network
%view(net)

% Plots
% Uncomment these lines to enable various plots.
%figure, plotperform(tr)
%figure, plottrainstate(tr)
%figure, plotresponse(testTargets,outputs)
%figure, ploterrcorr(errors)
%figure, plotinerrcorr(inputs,errors)

m=cell2mat(testTargets);
n=cell2mat(outputs);
j=1;
for i=1:690
    if isnan(m(1,i))
    else
        actual(1,j)=m(1,i);
        predict(1,j)=n(1,i+4);
        j=j+1;
    end
end 
        
        
        

% Closed Loop Network
% Use this network to do multi-step prediction.
% The function CLOSELOOP replaces the feedback input with a direct
% connection from the outout layer.
netc = closeloop(net);
[xc,xic,aic,tc] = preparets(netc,{},{},targetSeries);
yc = netc(xc,xic,aic);
perfc = perform(net,tc,yc)

% Early Prediction Network
% For some applications it helps to get the prediction a timestep early.
% The original network returns predicted y(t+1) at the same time it is given y(t+1).
% For some applications such as decision making, it would help to have predicted
% y(t+1) once y(t) is available, but before the actual y(t+1) occurs.
% The network can be made to return its output a timestep early by removing one delay
% so that its minimal tap delay is now 0 instead of 1.  The new network returns the
% same outputs as the original network, but outputs are shifted left one timestep.
nets = removedelay(net);
[xs,xis,ais,ts] = preparets(nets,{},{},targetSeries);
ys = nets(xs,xis,ais);
closedLoopPerformance = perform(net,tc,yc)

MAPE=sum(abs((actual-predict)./actual))/200;
MSE=sum((actual-predict).^2)/200;
%ts1=timeseries(actual,1:100);
%ts2=timeseries(predict,1:100);
plot(actual,'-bs','LineWidth',1,...
                'MarkerEdgeColor','k',...
                'MarkerFaceColor','g',...
                'MarkerSize',3);figure(gcf)
hold on;
plot(predict,'--*r');figure(gcf)
xlabel('time(10min)');
ylabel('wind speed(m/s)');
title('wind speed prediction by ANN(Blandford2009)');

legend('actual','predict');
hold off;

save ANNChester5step
